
class MergeCall:
    def set_key(self, a):
        self.cmd = 'set_key'
        self.args = a
        return self
    def merge(self, a):
        self.cmd = 'merge'
        self.args = a
        return self

class AsyncerError(Error):
    def __init__(self, msg, fun):
        super(msg)
        self.wrapped = fun


def asyncer(fun):
    merge_call = {}
    def wrap(ctx):
        def pret(ok, err):
            def inner(f,  opt):
                if opt:
                    ret_v = opt.ret_v
                    ret_throw =  opt.ret_throw
                    merge_key = opt.merge_key

                def _err(e, merge_key):
                    try:
                        raise e
                    except:
                        err(e)
                    if merge_key:
                        merge_call[merge_key].map(def(cb): cb.err(e);)
                        del merge_call[merge_key]

                if ret_throw:
                    v = ret_throw
                else:
                    try:
                        if not f:
                            f = fun.apply(ctx.self, ctx.args)
                            if not (f and f.next):
                                fname = fun.__name__ or fun.name or '<anonymous>'
                                raise AsyncerError(f'${fname} must be instance of Generator', fun)
                        v = f.next(ret_v)
                    except as e:
                        _err(e, merge_key)
                        return
                if isinstance(v.value, MergeCall):
                    if v.value.cmd == 'get_keys':
                        Promise.resolve(Object.keys(merge_call))
                        .then(def(ret_v):
                            inner(f, {ret_v, merge_key});
                        )
                    elif v.value.cmd == 'merge':
                        if (p = merge_call[v.value.args]):
                            p.push({ok: def(v): ok(v);, err: def(v): err(v);})
                            return
                        else:
                            merge_key = v.value.args
                            merge_call[merge_key] = []
                            Promise.resolve(None).then(def(ret_v): inner(f, {ret_v, merge_key});)
                    else:
                        Promise.resolve(None).then(def(ret_v): inner(f, {ret_v, merge_key});)
                elif not v.done:
                    if isinstance(v.value, Promise):
                        v.value.then(def(ret_v): inner(f, {ret_v, merge_key});,
                                     def(e):
                                         try:
                                             v = f.throw(e)
                                         except as e:
                                             _err(e, merge_key)
                                             return
                                         inner(f, {ret_throw: v,  merge_key});
                        )
                    else:
                        Promise.resolve(v.value).then(def(ret_v): inner(f, {ret_v, merge_key});)
                else:
                    ok(v.value)
                    if merge_key:
                        merge_call[merge_key].map(def(cb): cb.ok(v.value);)
                        del merge_call[merge_key]
            inner()
        return pret
    ret =  def():
        ctx = {self:this, args: arguments}
        p = Promise(wrap(ctx))
        return p
    ret.__name__ = fun.__name__ or fun.name
    return ret
